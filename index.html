<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defense Stock Treemap</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Next:ital,wght@0,200..800;1,200..800&display=swap" rel="stylesheet">
    
<style>
:root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #252525;
    --text-primary: #e0e0e0;
    --text-secondary: #b0b0b0;
    --text-tertiary: #808080;
    --border-light: #3a3a3a;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Atkinson Hyperlegible Next', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.4;
    padding: 20px;
    -webkit-font-smoothing: antialiased;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
}

header {
    padding: 20px 0 30px 0;
    border-bottom: 1px solid var(--border-light);
    margin-bottom: 30px;
}

h1 {
    font-size: 32px;
    font-weight: 700;
    margin-bottom: 10px;
}

.subtitle {
    font-size: 14px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.1em;
}

.last-updated {
    font-size: 12px;
    color: var(--text-tertiary);
    margin-top: 10px;
}

.controls {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.btn {
    background: var(--bg-secondary);
    border: 1px solid var(--border-light);
    color: var(--text-primary);
    padding: 8px 16px;
    border-radius: 8px;
    cursor: pointer;
    font-family: inherit;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    transition: all 0.2s;
}

.btn:hover {
    background: #2a2a2a;
}

#treemap {
    background: #f5f5f5;
    border: 3px solid #2a2a2a;
    border-radius: 0;
    overflow: hidden;
    position: relative;
    height: 800px;
}

.treemap-cell {
    position: absolute;
    border: 3px solid #ffffff;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    cursor: pointer;
    transition: opacity 0.2s;
    overflow: hidden;
    box-sizing: border-box;
}

.treemap-cell:hover {
    opacity: 0.85;
    z-index: 10;
}

.cell-ticker {
    font-size: 28px;
    font-weight: 800;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
    margin-bottom: 6px;
    letter-spacing: 0.02em;
}

.cell-marketcap {
    font-size: 22px;
    font-weight: 700;
    color: rgba(255,255,255,0.95);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
    margin-bottom: 8px;
}

.cell-change {
    font-size: 20px;
    font-weight: 700;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
    margin-bottom: 6px;
}

.cell-price {
    font-size: 16px;
    font-weight: 600;
    color: rgba(255,255,255,0.95);
    text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
}

.loading {
    text-align: center;
    padding: 40px;
    color: var(--text-tertiary);
    font-size: 14px;
}

.error {
    background: rgba(248, 113, 113, 0.1);
    border: 1px solid rgba(248, 113, 113, 0.3);
    color: #f87171;
    padding: 16px 20px;
    border-radius: 8px;
    margin: 20px;
    text-align: center;
}

.treemap-cell.small .cell-ticker { font-size: 20px; }
.treemap-cell.small .cell-marketcap { font-size: 16px; }
.treemap-cell.small .cell-change { font-size: 16px; }
.treemap-cell.small .cell-price { font-size: 13px; }

.treemap-cell.tiny .cell-ticker { font-size: 16px; }
.treemap-cell.tiny .cell-marketcap { font-size: 13px; }
.treemap-cell.tiny .cell-change { font-size: 13px; }
.treemap-cell.tiny .cell-price { font-size: 11px; }

.treemap-cell.micro .cell-ticker { font-size: 12px; }
.treemap-cell.micro .cell-marketcap { font-size: 11px; }
.treemap-cell.micro .cell-change { font-size: 11px; }
.treemap-cell.micro .cell-price { display: none; }
</style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸŽ¯ Defense Stock Market Cap Treemap</h1>
            <div class="subtitle">Size = Market Cap | Color = Performance</div>
            <div class="last-updated" id="lastUpdated">Loading...</div>
        </header>

        <div class="controls">
            <button class="btn" onclick="refreshData()">Refresh</button>
        </div>

        <div id="treemap">
            <div class="loading">Loading stock data...</div>
        </div>
    </div>

<script>
const SHEET_URL = 'https://docs.google.com/spreadsheets/d/1svXheHx4C1XVLITnVsW7nbT0v-B8tJxDviZG-Op2v58/gviz/tq?tqx=out:csv&gid=414313148';

let stockData = [];

async function fetchStockData() {
    try {
        console.log('Fetching data from sheet...');
        const response = await fetch(SHEET_URL + '&t=' + Date.now());
        if (!response.ok) throw new Error('Failed to fetch');
        
        const csv = await response.text();
        console.log('CSV received, first 200 chars:', csv.substring(0, 200));
        
        const lines = csv.split('\n');
        console.log('Total lines:', lines.length);
        
        const headers = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
        console.log('Headers:', headers);
        
        const tickerIndex = headers.indexOf('Ticker');
        const priceIndex = headers.indexOf('Price');
        const changeIndex = headers.indexOf('Change%');
        const marketCapIndex = headers.indexOf('Marketcap');
        
        console.log('Column indices:', { tickerIndex, priceIndex, changeIndex, marketCapIndex });
        
        if (tickerIndex === -1 || priceIndex === -1 || changeIndex === -1 || marketCapIndex === -1) {
            throw new Error('Missing required columns');
        }
        
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue;
            
            const values = lines[i].split(',').map(v => v.trim().replace(/^"|"$/g, ''));
            if (values.length > tickerIndex && values[tickerIndex]) {
                const ticker = values[tickerIndex];
                const percentChange = parseFloat(values[changeIndex].replace(/[^0-9.-]/g, ''));
                const marketCapRaw = values[marketCapIndex].replace(/[^0-9]/g, '');
                const marketCapBillions = parseFloat(marketCapRaw) / 1000000000;
                
                if (marketCapBillions > 0 && !isNaN(marketCapBillions)) {
                    data.push({
                        ticker: ticker,
                        price: parseFloat(values[priceIndex].replace(/[^0-9.]/g, '')),
                        percentChange: percentChange,
                        marketCap: marketCapBillions
                    });
                }
            }
        }
        
        console.log('Parsed data:', data.length, 'stocks');
        console.log('Sample:', data.slice(0, 3));
        return data;
    } catch (error) {
        console.error('Error fetching data:', error);
        throw error;
    }
}

function getColor(percentChange) {
    if (percentChange >= 5) return '#10b981';
    if (percentChange >= 3) return '#34d399';
    if (percentChange >= 2) return '#6ee7b7';
    if (percentChange >= 1) return '#86efac';
    if (percentChange > 0) return '#a7f3d0';
    if (percentChange === 0) return '#94a3b8';
    if (percentChange > -1) return '#fca5a5';
    if (percentChange > -2) return '#f87171';
    if (percentChange > -3) return '#ef4444';
    if (percentChange > -5) return '#dc2626';
    return '#b91c1c';
}

function squarify(data, x, y, width, height) {
    if (data.length === 0) return [];
    if (data.length === 1) {
        return [{
            ...data[0],
            x: x,
            y: y,
            width: width,
            height: height
        }];
    }
    
    const total = data.reduce((sum, d) => sum + d.value, 0);
    
    // Sort by size descending
    const sorted = [...data].sort((a, b) => b.value - a.value);
    
    const result = [];
    let remaining = [...sorted];
    let currentX = x;
    let currentY = y;
    let remainingWidth = width;
    let remainingHeight = height;
    
    while (remaining.length > 0) {
        const isHorizontal = remainingWidth >= remainingHeight;
        
        // Take items for this row/column
        let rowItems = [];
        let rowSum = 0;
        
        for (let i = 0; i < remaining.length; i++) {
            rowItems.push(remaining[i]);
            rowSum += remaining[i].value;
            
            // Stop if we've used enough space or this is the last item
            const proportion = rowSum / total;
            if (proportion > 0.3 || i === remaining.length - 1) {
                break;
            }
        }
        
        // Layout this row
        if (isHorizontal) {
            const rowWidth = (rowSum / total) * width;
            let offsetY = currentY;
            
            rowItems.forEach(item => {
                const itemHeight = (item.value / rowSum) * remainingHeight;
                result.push({
                    ...item,
                    x: currentX,
                    y: offsetY,
                    width: rowWidth,
                    height: itemHeight
                });
                offsetY += itemHeight;
            });
            
            currentX += rowWidth;
            remainingWidth -= rowWidth;
        } else {
            const rowHeight = (rowSum / total) * height;
            let offsetX = currentX;
            
            rowItems.forEach(item => {
                const itemWidth = (item.value / rowSum) * remainingWidth;
                result.push({
                    ...item,
                    x: offsetX,
                    y: currentY,
                    width: itemWidth,
                    height: rowHeight
                });
                offsetX += itemWidth;
            });
            
            currentY += rowHeight;
            remainingHeight -= rowHeight;
        }
        
        remaining = remaining.slice(rowItems.length);
        
        // Recalculate total for remaining items
        const newTotal = remaining.reduce((sum, d) => sum + d.value, 0);
        if (newTotal === 0) break;
    }
    
    return result;
}

function createTreemap(data, width, height) {
    const sorted = [...data].sort((a, b) => b.marketCap - a.marketCap);
    const withValue = sorted.map(d => ({ ...d, value: d.marketCap }));
    return squarify(withValue, 0, 0, width, height);
}

function render() {
    const container = document.getElementById('treemap');
    console.log('Rendering treemap...');
    console.log('Stock data length:', stockData.length);
    
    if (stockData.length === 0) {
        container.innerHTML = '<div class="loading">No data available</div>';
        return;
    }
    
    const rect = container.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    
    console.log('Container dimensions:', width, 'x', height);
    
    const layout = createTreemap(stockData, width, height);
    console.log('Layout created:', layout.length, 'cells');
    console.log('Sample layout:', layout.slice(0, 2));
    
    container.innerHTML = layout.map(item => {
        const color = getColor(item.percentChange);
        const arrow = item.percentChange >= 0 ? 'â–²' : 'â–¼';
        const sign = item.percentChange >= 0 ? '+' : '';
        
        const area = item.width * item.height;
        let sizeClass = '';
        if (area < 5000) sizeClass = 'micro';
        else if (area < 12000) sizeClass = 'tiny';
        else if (area < 25000) sizeClass = 'small';
        
        let marketCapDisplay;
        if (item.marketCap >= 1000) {
            marketCapDisplay = '$' + (item.marketCap / 1000).toFixed(2) + 'T';
        } else if (item.marketCap >= 1) {
            marketCapDisplay = '$' + item.marketCap.toFixed(1) + 'B';
        } else {
            marketCapDisplay = '$' + (item.marketCap * 1000).toFixed(0) + 'M';
        }
        
        return `
            <div class="treemap-cell ${sizeClass}" style="
                left: ${item.x}px;
                top: ${item.y}px;
                width: ${item.width}px;
                height: ${item.height}px;
                background-color: ${color};
            ">
                <div class="cell-ticker">${item.ticker}</div>
                <div class="cell-marketcap">${marketCapDisplay}</div>
                <div class="cell-change">${arrow} ${sign}${item.percentChange.toFixed(2)}%</div>
                <div class="cell-price">$${item.price.toFixed(2)}</div>
            </div>
        `;
    }).join('');
    
    console.log('Render complete');
    
    document.getElementById('lastUpdated').textContent = 
        `Last updated: ${new Date().toLocaleTimeString()}`;
}

async function refreshData() {
    const container = document.getElementById('treemap');
    container.innerHTML = '<div class="loading">Refreshing...</div>';
    
    try {
        stockData = await fetchStockData();
        render();
    } catch (error) {
        container.innerHTML = '<div class="error">Failed to load data. Please try again.</div>';
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(render, 250);
});

refreshData();
setInterval(refreshData, 5 * 60 * 1000);
</script>
</body>
</html>
